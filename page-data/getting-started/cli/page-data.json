{"componentChunkName":"component---src-pages-getting-started-cli-index-mdx","path":"/getting-started/cli/","result":{"pageContext":{"frontmatter":{"title":"Developer Tools CLI"},"relativePagePath":"/getting-started/cli/index.mdx","titleType":"page","MdxNode":{"id":"8ad3acbf-bd97-5ab8-877a-4ae2d512cc3a","children":[],"parent":"310c1ff2-1728-54a8-bf9c-72bdecbefd0d","internal":{"content":"---\ntitle: Developer Tools CLI\n---\nimport Globals from 'gatsby-theme-carbon/src/templates/Globals';\n\n<PageDescription>\n\nThe <Globals name=\"shortName\" /> Command Line Interface (CLI)\n\n</PageDescription>\n\nThe <Globals name=\"longName\" /> includes the IBM Garage for Cloud (IGC) Command Line Interface (CLI).\nThe [<Globals name=\"igccli\" />](https://github.com/ibm-garage-cloud/ibm-garage-cloud-cli) provides a set of helpful\nutilities that can be invoked from the command line. It's designed to automate and simplify complicated and repetitive\ntasks thus allowing developers to be more productive.\n\nThe CLI is not a <Globals name=\"shortName\" /> requirement as all its actions can be performed manually instead. For each command, the equivalent manual steps are also given for the sake of full transparency and to take away any notion of \"magic\" that the CLI might be performing.\n\nSome of the utilities provided by the CLI include:\n- Register your application's Git repository into a CI pipeline ([Jenkins](/guides/continuous-integration), [Tekton](/guides/continuous-integration-tekton), etc.).\n- List the ingress URLs and route URLs defined within the cluster.\n- List the connection information (endpoints, user names, and passwords) for the tools configured in the environment.\n- Help copy `config maps` and `secrets` into new projects/namespace.\n- Enable existing <Globals name=\"templates\" /> with the necessary artifacts to be integrated easily into the <Globals name=\"env\" />.\n\nYou can either install the CLI or the Cloud Shell Commands environment on your computer:\n\n<Accordion>\n\n<AccordionItem title=\"Install the Cloud Shell\" open=\"true\">\n\nFollow the instructions in the [cloud-shell-commands readme](https://github.com/ibm-garage-cloud/cloud-shell-commands/blob/master/README.md).\n\n</AccordionItem>\n\n<AccordionItem title=\"Install the CLI\" >\n\n- Install the CLI:\n    ```bash\n    npm i -g @ibmgaragecloud/cloud-native-toolkit-cli\n    ````\n\n- Verify the version:\n    ```bash\n    igc --version\n    ```\n\n</AccordionItem>\n\n</Accordion>\n\n## Invoking the CLI\n\n- Once the CLI is installed, the `igc` executable will be available in your system. Running `igc --help` will list the available commands.\n- The output text will be similar to the following:\n\n    ```\n    $ igc --help\n    IBM Garage Cloud-Native Toolkit CLI (https://cloudnativetoolkit.dev)\n\n    Usage: igc <command> [args]\n\n    Commands:\n      igc create-webhook      Create a git webhook for a given Jenkins pipeline\n      igc credentials         Lists the urls and credentials for the tools deployed\n                              to the cluster\n      igc dashboard           Open the Developer Dashboard in the default browser\n      igc enable              Enable the current repository with pipeline logic\n      igc endpoints           List the current ingress hosts for deployed apps in a\n                              namespace      [aliases: ingress, endpoint, ingresses]\n      igc generate-token      Generate a Jenkins api token\n      igc git-secret [name]   Create a kubernetes secret that contains the url,\n                              username, and personal access token for a git repo\n      igc jenkins-auth        Generate a Jenkins api token and register it as\n                              kubernetes secret\n      igc sync [namespace]    Create a namespace (if it does not exist) and prepare\n                              it with the necessary configuration\n                                                       [aliases: project, namespace]\n      igc pipeline            Register a pipeline for the current code repository\n      igc tool-config [name]  Create the config map and secret for a tool configured\n                              in the environment\n      igc vlan                Print out the vlan values\n      igc yq <command>        lightweight yaml command-line processor that addresses\n                              deficiencies with the existing `yq` command\n\n    Options:\n      --version  Show version number                                       [boolean]\n      --help     Show help                                                 [boolean]\n    ```\n\n- The <Globals name=\"igccli\" /> will now install the commands as plugins to the `kubectl` and `oc` CLIs.\n- For example, all of the following commands are equivalent:\n\n    ```\n    igc pipeline\n    kubectl pipeline\n    oc pipeline\n    ```\n\n### Prerequisite tools\n\n<InlineNotification>\n\nSome of the commands provided by the <Globals name=\"igccli\" /> orchestrate interactions between other CLIs. To get\nstarted please install the [prerequisite tools](/getting-started/devenvsetup), in particular:\n- <Globals name=\"kube\" /> CLI.\n- <Globals name=\"ocp\" /> CLI.\n- <Globals name=\"ic\" /> CLI--used to interact with IBM Cloud virtual LANs.\n\n</InlineNotification>\n\n### Log into your cluster\n\nMost of the commands provided by the <Globals name=\"igccli\" /> interact with a cluster, so you need to log in to be able to run these.\n\n<Accordion>\n\n<AccordionItem title=\"OpenShift\" open=\"true\">\n\n```bash\noc login --server=<url> --token=<apikey>\n```\n</AccordionItem>\n\n<AccordionItem title=\"Kubernetes\">\n\n```bash\nibmcloud ks cluster config --cluster <CLUSTER>\n```\n\n</AccordionItem>\n\n</Accordion>\n\n### Log in to your IBM Cloud account\n\n- Log in to your <Globals name=\"ic\" /> account with the correct region and resource group:\n\n    ```bash\n    ibmcloud login -a cloud.ibm.com -r <region> -g <resource group>\n    ```\n\n## Available commands\n\n### `dashboard`\n\nOpens the Developer Dashboard in the default browser. If the default browser has not been configured, then it prints the dashboard URL.\n\nThe dashboard displays the <Globals name=\"shortName\" /> tools configured within the cluster along with links to activation content and Starter Kits to initiate a project quickly.\n\nThis command requires to be logged into the cluster so the context is established.\n\n**Command flags**\n- `-n`: the namespace where the dashboard has been deployed; the default is `tools`.\n\n**Usage**\n\n<Tabs>\n<Tab label=\"CLI\">\n\nThe command syntax is:\n\n```bash\nigc dashboard\n```\n</Tab>\n<Tab label=\"OpenShift\">\n\nThe following commands does the same function on OpenShift:\n\n```bash\nHOST=$(oc get routes/dashboard -n tools -o jsonpath='{.spec.host}')\nopen \"https://$HOST\"\n```\n</Tab>\n<Tab label=\"Kubernetes\">\n\nThe following commands does the same function on Kubernetes:\n\n```bash\nHOST=$(kubectl get ingress/developer-dashboard -n tools -o jsonpath='{.spec.rules[0].host}')\nopen \"https://$HOST\"\n```\n\n</Tab>\n</Tabs>\n\n**Related commands**\n\n- [`credentials`](#credentials): shows the same credentials information that can be seen in the dashboard.\n- [`tool-config`](#tool-config): allows adding configuration for additional tools to the cluster, making them available to the dashboard and the `credentials` command.\n\n### `credentials`\n\nLists the endpoints, user names, and passwords for the tools configured in the environment. This is the easiest way to get the login credentials for each of the installed tools. Ideally, all of the tools will be accessible via SSO, at which point this command will be obsolete.\n\nThis command works by reading the information available in the cluster. For each tool installed by the toolkit, a config map and a secret are created to store its URL and credentials. This information is used in several ways within the environment:\n\n- Provide configuration information to the pipelines.\n- Populate the tiles on the Developer Dashboard.\n- Populate the results of the `credentials` command.\n\nThis command requires that the login context for the cluster has already been established.\n\n**Command flags**\n- `-n`: the namespace where the tools have been deployed. The default value is `tools`.\n\n**Usage**\n\n<Tabs>\n<Tab label=\"CLI\">\n\nThe command is used in the following way:\n\n```bash\nigc credentials\n```\n\nIt will output the credentials in JSON format:\n\n```bash\nCredentials:  {\n  argocd: {\n    user: 'admin',\n    password: '12345678',\n    url: 'https://argocd-tools.mycluster.us-east.containers.appdomain.cloud'\n  },\n  . . .\n  dashboard: {\n    url: 'https://dashboard-tools.mycluster.us-east.containers.appdomain.cloud'\n  },\n  . . .\n}\n```\n\n</Tab>\n<Tab label=\"OpenShift or Kubernetes\">\n\nThe following commands does the same function (note the dependency on `jq`):\n\n```bash\n# config maps\nkubectl get configmap -n tools -l grouping=garage-cloud-native-toolkit -o json | \\\n  jq '[.items[] | select(.metadata.name != \"ibmcloud-config\").data]'\n\n# secrets\nkubectl get secret -n tools -l grouping=garage-cloud-native-toolkit -o json | \\\n  jq '[.items[] | select(.metadata.name != \"ibmcloud-apikey\").data | with_entries(.value |= @base64d)]'\n```\n</Tab>\n</Tabs>\n\n### `endpoints`\n\nLists the ingress and/or route URLs for the applications in a given namespace. If a namespace is not provided as an argument, it will try to get it from the current context. The results are shown in an interactive menu. If one of the endpoints is selected, it will display the URL and launch it in the default browser. Selecting `Exit` will print the full list of endpoints and exit.\n\nThis command requires that the login context for the cluster has already been established.\n\n**Command flags**\n- `-n`: the namespace from which the endpoints will be retrieved. The value will be read from the current context if not provided.\n\n**Usage**\n\n<Tabs>\n<Tab label=\"CLI\">\n\nThe command is used in the following way:\n\n```bash\nigc endpoints\n```\n\n</Tab>\n<Tab label=\"OpenShift\">\n\nThe following commands list the route and ingress endpoints:\n\n```bash\n# routes\nkubectl get route -n tools\n\n# ingress\nkubectl get ingress -n tools\n```\n</Tab>\n<Tab label=\"Kubernetes\">\n\nThe following commands list the ingress endpoints:\n\n```bash\nkubectl get ingress -n tools\n```\n</Tab>\n</Tabs>\n\n### `sync`\n\nCreates a Kubernetes namespace or OpenShift project (if it doesn't already exist) and sets it up so that the namespace\ncan be used as a target for application deployments and/or host the <Globals name=\"env\" />.\n\nThe command performs two major functions, 1) set up a service account in the namespace with the pull secret(s) for the IBM Container Registry and 2) synchronize the `ConfigMaps` and `Secrets` from a template namespace to create a \"development\" namespace.\n\nOnce the command has run successfully, it will set the provided namespace in the current context (e.g. equivalent to `oc project X`).\n\nThe pull secret(s) are required for pods to pull images stored in the IBM Container Registry. When a cluster is created in IBM Cloud, a pull secret is provided in the `default` namespace.\n\nFor a pod in another namespace to use the pull secret, it must first be copied into that namespace. After that, the pod either\nneeds to reference the pull secret directly, or the service account used by the resource needs to have a reference to\nthe secret. The CLI copies the pull secret over and adds it to the service account so the pod can take either approach.\n\nThe other function this command performs is to copy relevant `ConfigMaps` and `Secrets` needed for development into the namespace. Managing resources across namespaces (particularly `ConfigMaps` and `Secrets`) is a\ncommon challenge in Kubernetes environments. We have provided the command at this time to simplify the steps required\nto get everything ready. Ultimately, this problem seems like an ideal one for a command to solve and when another one is\navailable (either from the Toolkit or elsewhere) this one will be retired or transitioned.\n\nThere are two different types of namespaces that the command will set up:\n\n- \"release\" namespace where applications can be deployed (e.g. test, staging).\n\n-OR-\n\n- \"development\" namespace where DevOps pipelines can be run and where application components can be deployed\n(e.g. dev).\n\nBoth \"release\" and \"development\" namespaces will have the pull secret(s) created. However, only the \"development\"\none will also have the `ConfigMaps` and `Secrets` copied over.\n\n**Command flags**\n- `-t`: the template namespace that will be the source of the `config maps` and `secrets`. The default is `tools`.\n- `-z`: the name of the service account. The default is `default`.\n- `--dev`: flag indicating the namespace should be set for development.\n- `--verbose`: flag indicating that the console output should persist on the screen.\n\n**Usage**\n\n<Tabs>\n<Tab label=\"CLI\">\n\nCreate a `test` namespace:\n\n```bash\nigc sync test\n```\n\nCreate a `dev` namespace for development:\n\n```bash\nigc sync dev --dev\n```\n</Tab>\n<Tab label=\"Manual pull secret setup\">\n\nThe following commands will copy the pull secret(s) from the `default` namespace and add them to the service account:\n\n```bash\nexport NAMESPACE=\"NAMESPACE\"\nexport SERVICE_ACCOUNT=\"default\"\n\nif [[ $(kubectl get secrets -n \"${NAMESPACE}\" -o jsonpath='{ range .items[*] }{ .metadata.name }{ \"\\n\" }{ end }' | grep icr | wc -l | xargs) -eq 0 ]]; then\n    echo \"*** Copying pull secrets from default namespace to the ${NAMESPACE} namespace\"\n\n    kubectl get secrets -n default | grep icr | sed \"s/\\([A-Za-z-]*\\) *.*/\\1/g\" | while read default_secret; do\n        kubectl get secret ${default_secret} -n default -o yaml --export | sed \"s/name: default-/name: /g\" | kubectl -n ${NAMESPACE} create -f -\n    done\nelse\n    echo \"*** Pull secrets already exist in the ${NAMESPACE} namespace\"\nfi\n\n\nEXISTING_SECRETS=$(kubectl get serviceaccount/${SERVICE_ACCOUNT} -n \"${NAMESPACE}\" -o json  | tr '\\n' ' ' | sed -E \"s/.*imagePullSecrets.: \\[([^]]*)\\].*/\\1/g\" | grep icr | wc -l | xargs)\nif [[ ${EXISTING_SECRETS} -eq 0 ]]; then\n    echo \"*** Adding secrets to serviceaccount/${SERVICE_ACCOUNT} in the ${NAMESPACE} namespace\"\n\n    PULL_SECRETS=$(kubectl get secrets -n \"${NAMESPACE}\" -o jsonpath='{ range .items[*] }{ \"{\\\"name\\\": \\\"\"}{ .metadata.name }{ \"\\\"}\\n\" }{ end }' | grep icr | grep -v \"${NAMESPACE}\" | paste -sd \",\" -)\n    kubectl patch -n \"${NAMESPACE}\" serviceaccount/${SERVICE_ACCOUNT} -p \"{\\\"imagePullSecrets\\\": [${PULL_SECRETS}]}\"\nelse\n  export TEMPLATE_NAMESPACE=\"tools\"\n  export NAMESPACE=\"NAMESPACE\"\n\n  kubectl get configmap -l grouping=garage-cloud-native-toolkit -n ${TEMPLATE_NAMESPACE} -o jsonpath='{ range .items[*] }{ .metadata.name }{ \"\\n\" }{ end }' | \\\n    while read cm; do\n      kubectl get configmap ${cm} --namespace ${TEMPLATE_NAMESPACE} --export -o yaml | \\\n        kubectl apply --namespace $NAMESPACE -f -\n    done\n\n  kubectl get secret -l grouping=garage-cloud-native-toolkit -n ${TEMPLATE_NAMESPACE} -o jsonpath='{ range .items[*] }{ .metadata.name }{ \"\\n\" }{ end }' | \\\n    while read cm; do\n      kubectl get secret ${cm} --namespace ${TEMPLATE_NAMESPACE} --export -o yaml | \\\n        kubectl apply --namespace $NAMESPACE -f -\n    done\n\n```\n</Tab>\n</Tabs>\n\n### `pipeline`\n\nConnects a Git repository branch to either a Jenkins or Tekton CI pipeline in the <Globals name=\"env\" /> and triggers\nan initial build. A webhook is created so that when a new commit is added to the branch, the pipeline is triggered\nto rebuild and redeploy the app with the updated code. The Git repository needs to be hosted in a service that supports triggers such as GitHub or GitLab.\n\nThis command requires the user to be logged into the cluster through a terminal, and that the terminal's current directory be your local copy of the Git repository as it uses its configuration to find the server copy.\n\nIf Jenkins or Tekton are not specified when the command is invoked you will be prompted for which CI tool to use.\nThe command will also prompt for the username and personal access token to access the Git repository unless those are\nprovided as command-line parameters. It will also prompt you for the branch to use to trigger builds. The default is the current branch.\n\n**Command flags**\n- `-n`: the deployment namespace. If not provided, the namespace from the current context will be used.\n- `-u`: the username for accessing the Git repository.\n- `-p`: the personal access token for accessing the Git repository.\n- `--jenkins`: deploy using a Jenkins pipeline.\n- `--tekton`: deploy using a Tekton pipeline.\n\n**Usage**\n\n<Tabs>\n<Tab label=\"CLI\">\nCreate a Jenkins pipeline in the `dev` namespace and prompt for the Git credentials:\n\n```bash\nigc pipeline --jenkins\n```\n\nCreate a Tekton pipeline in the `my-dev` namespace, using the Git credentials `gituser` and `gitpat`:\n\n```bash\nigc pipeline -n my-dev -u gituser -p gitpat --tekton\n```\n</Tab>\n<Tab label=\"Manual Steps for Tekton\">\n\nThe following steps are required to manually configure a **Tekton**\npipeline in your development cluster:\n<br></br>\n\n\n- Configure the service account `pipeline` if it doesn't exist. In OpenShift 4 the operator takes care of it, so you can skip this step.\n  ```bash\n  oc create serviceaccount pipeline\n  oc adm policy add-scc-to-user privileged -z pipeline\n  oc adm policy add-role-to-user edit -z pipeline\n  ```\n- Clone the tasks from the `tools` namespace into the `new-namespace` one:\n  ```\n  kubectl get tasks --export -o yaml -n tools  | sed s/\"namespace: tools/namespace: $(oc project -q)\"/ | kubectl apply -f -\n  ```\n- Clone the pipelines from the `tools` namespace into the `new-namespace` one:\n  ```\n  kubectl get pipelines --export -o yaml -n tools  | sed s/\"namespace: tools/namespace: $(oc project -q)\"/ | kubectl apply -f -\n  ```\n\n### Pipeline Resource\n\n- The `tkn` CLI creates a pipeline resource for a Git repository. Use `git` as resource type, replace the URL with the correct GitHub one for your repository, and set the desired branch for `revision`:\n  ```\n  tkn resource create\n  ? Enter a name for a pipeline resource : nodejs-typescript-git\n  ? Select a resource type to create : git\n  ? Enter a value for url :  https://github.com/{user or org}/{app}\n  ? Enter a value for revision :  master\n  New git resource \"nodejs-typescript-git\" has been created\n  ```\n- To create a Pipeline resource for the docker image registry, you can use the internal registry in OpenShift or use an external registry like IBM Container Registry (credentials need setup).\n  - With the `tkn` CLI, create an `image` resource:\n    ```\n    tkn resource create\n    ```\n  - Select `image` for type.\n\n    - Enter the corresponding `url` for the container registry, and replace `{new-namespace}` with your namespace.\n\n    - For OCP 3 internal registry use `docker-registry.default.svc:5000/{new-namespace}/node-typescript:latest`.\n\n    - For OCP 4 or CRC internal registry use `image-registry.openshift-image-registry.svc:5000/{new-namespace}/node-typescript:latest`.\n\n    - For an external registry like IBM Container Registry based on region use `us.icr.io/{namespace}/node-typescript:latest`, replacing `{namespace}` with an existing namespace in your IBM Cloud.\n    ```\n    tkn resource create\n    ? Enter a name for a pipeline resource : nodejs-typescript-image\n    ? Select a resource type to create : image\n    ? Enter a value for url :  docker-registry.default.svc:5000/dev/node-typescript:latest\n    ? Enter a value for digest :\n    New image resource \"nodejs-typescript-image\" has been created\n    ```\n\n- List the available pipelines:\n  ```\n  tkn pipeline ls\n  NAME              AGE              LAST RUN   STARTED   DURATION   STATUS\n  igc-java-gradle   33 minutes ago   ---        ---       ---        ---\n  igc-nodejs        33 minutes ago   ---        ---       ---        ---\n  ```\n  In this case we can use `igc-java-gradle` for java or `igc-nodejs` for nodejs.\n\n- Start the pipeline using the `git` and `image` pipeline resources.\n  Set the following environment variables for convienience:\n  ```\n  export PIPELINE=igc-nodejs\n  export GIT=nodejs-typescript-git\n  export IMAGE=nodejs-typescript-image\n  ```\n  Then run `tkn pipeline start` with the input arguments using the service account `pipeline`:\n  ```\n  tkn pipeline start \\\n  ${PIPELINE} \\\n  -r git-source=${GIT} \\\n  -r docker-image=${IMAGE} \\\n  -s pipeline\n  ```\n\n### Create a Git Webhook\n\n- Open the Tekton Dashboard from the main Tools Dashboard or the ICPA landing page.\n\n- Create a Webhook in the Tekton Dashboard\n\n  - Click **Webhook** on the menu.\n  - Click **Add Webhook** and enter the information for the webhook.\n    - Name: **insert name**.\n    - Repository URL: **template git repo URL**.\n    - Access Token: Create GitHub access token with permission minimum write:repo_hook.\n    - Namespace: **insert namespace**.\n    - Pipeline: select **igc-java-gradle** or **igc-nodejs**.\n    - Service Account: **pipeline**.\n    - Docker Registry:\n      - For OCP 3 internal registry use `docker-registry.default.svc:5000/{new-namespace}`.\n      - For OCP 4 or CRC internal registry use `image-registry.openshift-image-registry.svc:5000/{new-namespace}`.\n      - For an external registry like IBM Container Registry based on region use `us.icr.io/{namespace}` replacing `{namespace}` with an existing namespace from your IBM Cloud. Make sure to configure docker credentials in the Tekton Dashboard using your IAM API Key and `iamapikey` for the your namespace username.\n\n- Check that the webhook is created in the GitHub repository (Settings - Webhooks).\n\n- Make a commit to the git repo and push it to the remote git repository, or click on **Pipelines**\nand manually trigger a pipeline build.\n\n</Tab>\n<Tab label=\"Manual steps for Jenkins on OpenShift\">\n\n### 1. Provision Jenkins Ephemeral\n\nJenkins Ephemeral provides a Kubernetes native version of Jenkins that dynamically provisions build agents on-demand.\nIt's _ephemeral_ in the sense that it doesn't allocate any persistent storage in the cluster.\n\n1. Set the project/namespace:\n\n```bash\noc project {NAMESPACE}\n```\n\nwhere:\n- `{NAMESPACE}` is the development namespace where the pipelines will run.\n\n2. Run the following command to provision the Jenkins instance in your namespace:\n\n```bash\noc new-app jenkins-ephemeral\n```\n\n3. Open the OpenShift console as described in the login steps above.\n\n4. Select `Workloads -> Pods` from the left-hand menu.\n\n5. At the top of the page select your project/namespace from the drop-down list to see the Jenkins instance running.\n\n### 2. Give the `jenkins` service account `privileged` access\n\nAll of the <Globals name=\"shortName\"/> pipelines use `buildah` to build and push the container image to the registry.\nUnfortunately, the `buildah` container must run as root. By default, OpenShift does not allow containers to run as the\nroot user and special permissions are required for the pipeline to run.\n\nWith the Jenkins build engine, all the build processes run as the `jenkins` service account. For the pipeline\ncontainer to run as root on OpenShift we need to assign the `privileged` security context constraint (scc) to\nthe `jenkins` service account with the following command:\n\n```bash\noc project {NAMESPACE}\noc adm policy add-scc-to-user privileged -z jenkins\n```\n\nwhere:\n - `{NAMESPACE}` should be the name you claimed in the box note prefixed to `-dev` (e.g. user01-dev).\n\n### 3. Create a secret with Git credentials\n\nFor Jenkins to have access to the Git repository, particularly if it is a private repository, a Kubernetes\nsecret containing the git credentials needs to be added.\n\n1. Create a personal access token (if you don't already have one) using the prerequisites instructions:\nhttps://cloudnativetoolkit.dev/getting-started/prereqs#configure-github-personal-access-token\n\n2. Copy the following into a file called `gitsecret.yaml` and update {Git-Username}, and {Git-PAT}:\n\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  annotations:\n    build.openshift.io/source-secret-match-uri-1: https://github.com/*\n  labels:\n    jenkins.io/credentials-type: usernamePassword\n  name: git-credentials\ntype: kubernetes.io/basic-auth\nstringData:\n  username: {Git-Username}\n  password: {Git-PAT}\n```\n\nwhere:\n - `Git-Username` is the username that has access to the git repo\n - `Git-PAT` is the personal access token of the git user\n\n2. After logging into the cluster, create the secret by running the following:\n\n```bash\noc project {NAMESPACE}\noc create -f gitsecret.yaml\n```\n\nwhere:\n - `{NAMESPACE}` is the development namespace where the pipelines will run.\n\n### 3. Create the build config\n\nOn OpenShift 4.3, Jenkins is built into the OpenShift console and the build pipelines can be managed using Kubernetes\ncustom resources. The following steps will manually create the build pipeline for the new application.\n\n1. Copy the following into a file called `buildconfig.yaml` and update {Name}, {Secret}, {Git-Repo-URL},\nand {Namespace}:\n\n```yaml\napiVersion: v1\nkind: BuildConfig\nmetadata:\n  name: {Name}\nspec:\n  triggers:\n  - type: GitHub\n    github:\n      secret: my-secret-value\n  source:\n    git:\n      uri: {Git-Repo-URL}\n      ref: master\n  strategy:\n    jenkinsPipelineStrategy:\n      jenkinsfilePath: Jenkinsfile\n      env:\n      - name: CLOUD_NAME\n        value: openshift\n      - name: NAMESPACE\n        value: {NAMESPACE}\n```\n\nwhere:\n - `Name` is the name of your pipeline.\n - `Git-Repo-URL` is the HTTPS URL to the Git repository.\n - `{NAMESPACE}` is the development namespace where the pipelines will run.\n\n2. Assuming you are still logged into the cluster, create the `buildconfig` resource:\n\n```bash\noc project {NAMESPACE}\noc create -f buildconfig.yaml\n```\n\nwhere:\n - `{NAMESPACE}` is the development namespace where the pipelines will run.\n\n### 4. View the pipeline in the OpenShift console\n\n1. Open the cluster's OpenShift console.\n2. Select Builds -> Build Config.\n3. Select your project/namespace (i.e. `{NAMESPACE}`) from the top.\n4. The build pipeline that was created in the previous step should appear.\n5. Manually trigger the pipeline by selecting `Start Build` the menu button on the right side of the row.\n\n### 5. Create the webhook\n\n1. Run the following commands to get the webhook details from the build config:\n\n```\noc project {NAMESPACE}\noc describe bc {Name}\n```\n\nwhere:\n - `{Name}` is the name used in the previous step for the build config.\n - `{NAMESPACE}` is the development namespace where the pipelines will run.\n\nThe webhook URL will have a structure similar to:\n\n`http://{openshift_api_host:port}/oapi/v1/namespaces/{namespace}/buildconfigs/{name}/webhooks/{secret}/generic`\n\nIn this case `{secret}` will be `my-secret-value`.\n\n2. Open a browser to the GitHub repository deployed in the previous step from the build configuration.\n\n3. Select `Settings`, then `Webhooks` and press `Add webhook`.\n\n4. Paste the webhook URL from the previous step into `Payload url`.\n\n5. Set the content-type to `application/json` and leave the rest of the values with the defaults.\n\n6. Press `Add webhook` to create the webhook.\n\n7. Press the button to test the webhook to ensure that everything was done properly.\n\n8. Go back to your project code and push a change to one of the files.\n\n9. Go to the Build pipeline page in the OpenShift console to check that the build was triggered.\n\n</Tab>\n<Tab label=\"Manual steps for Jenkins on Kubernetes\">\n\nTBD\n\n</Tab>\n</Tabs>\n\n### `enable`\n\nAdds DevOps artifacts to a Git repository that the <Globals name=\"env\" /> uses to deploy the app. The command displays a\nlist of available pipelines and applies the one you select to your repository. \n\nThis command DOES NOT require the user to be logged into an IBM Cloud account nor the cluster through the terminal. It DOES\nrequire that the terminal's current directory is the one for your local copy of the Git repository.\n\nThe command will add several files to the local repo which you need to commit and push them to the server repo. These include (but are not limited to):\n\n- Helm chart.\n- `Jenkinsfile`.\n\nOnce these are pushed, run `igc pipeline` to connect your repo to a pipeline in the environment.\n\n**Command flags**\n- `--repo`: the set of pipelines to choose from; the default is https://github.com/ibm-garage-cloud/garage-pipelines.\n- `-p`: the name of the pipeline to be installed. If not provided, you will be prompted for it.\n- `-b`: the branch from which the pipeline will be installed. The default is `stable`.\n- `r`: the version number of the pipeline to be installed. The default is `latest`.\n\n**Usage**\n\n<Tabs>\n<Tab label=\"CLI\">\n\n1. Before running the command, make sure you have a clean repository with no unstaged changes. Either commit any\nchanges or stash them temporarily with `git stash`. It is particularly important that any changes to the pipeline be\ndealt with.\n\n2. Apply the pipeline updates using the following CLI command:\n\n```bash\nigc enable\n```\n\n3. Review the changes using `git diff` and revert any application-specific changes that should remain (e.g.\ncustomization to the Jenkins pipeline in the `Jenkinsfile`, specific values added to `values.yaml`, customizations\nto the templates in the Helm chart).\n\n4. Commit the changes when you are happy with them.\n\n</Tab>\n<Tab label=\"Manual steps\">\n\nThe following manual steps are equivalent to the `igc enable` command:\n\n1. Before updating the pipelines, make sure you have a clean repository with no unstaged changes. Either commit any\nchanges or stash them temporarily with `git stash`. It is particularly important that any changes to the pipeline be\ndealt with.\n\n2. Download the `index.yaml` file containing the available pipeline versions:\n\n    ```bash\n    curl -O https://ibm-garage-cloud.github.io/garage-pipelines/index.yaml\n    ```\n\n3. Look through the `index.yaml` file to identify the URL for the desired pipeline branch and version.\n\n4. With the PIPELINE_URL from the previous step, run the following to download the pipeline tar-ball:\n\n    ```bash\n    curl -O ${PIPELINE_URL}\n    ```\n\n5. Extract the tar-ball into your repository directory. You will be prompted to overwrite files. Overwrite as\nappropriate:\n\n    ```bash\n    tar xzf ${PIPELINE_FILE}\n    ```\n\n6. Review the changes using `git diff` and revert any application-specific changes that should remain like\ncustomization to the Jenkins pipeline in the `Jenkinsfile`, specific values added to `values.yaml` or customizations\nto the templates in the helm chart.\n\n7. Commit changes once you are happy with them.\n\n</Tab>\n</Tabs>\n","type":"Mdx","contentDigest":"a56646cf063ee02a33783a1ccf919ed1","counter":1001,"owner":"gatsby-plugin-mdx"},"frontmatter":{"title":"Developer Tools CLI"},"exports":{},"rawBody":"---\ntitle: Developer Tools CLI\n---\nimport Globals from 'gatsby-theme-carbon/src/templates/Globals';\n\n<PageDescription>\n\nThe <Globals name=\"shortName\" /> Command Line Interface (CLI)\n\n</PageDescription>\n\nThe <Globals name=\"longName\" /> includes the IBM Garage for Cloud (IGC) Command Line Interface (CLI).\nThe [<Globals name=\"igccli\" />](https://github.com/ibm-garage-cloud/ibm-garage-cloud-cli) provides a set of helpful\nutilities that can be invoked from the command line. It's designed to automate and simplify complicated and repetitive\ntasks thus allowing developers to be more productive.\n\nThe CLI is not a <Globals name=\"shortName\" /> requirement as all its actions can be performed manually instead. For each command, the equivalent manual steps are also given for the sake of full transparency and to take away any notion of \"magic\" that the CLI might be performing.\n\nSome of the utilities provided by the CLI include:\n- Register your application's Git repository into a CI pipeline ([Jenkins](/guides/continuous-integration), [Tekton](/guides/continuous-integration-tekton), etc.).\n- List the ingress URLs and route URLs defined within the cluster.\n- List the connection information (endpoints, user names, and passwords) for the tools configured in the environment.\n- Help copy `config maps` and `secrets` into new projects/namespace.\n- Enable existing <Globals name=\"templates\" /> with the necessary artifacts to be integrated easily into the <Globals name=\"env\" />.\n\nYou can either install the CLI or the Cloud Shell Commands environment on your computer:\n\n<Accordion>\n\n<AccordionItem title=\"Install the Cloud Shell\" open=\"true\">\n\nFollow the instructions in the [cloud-shell-commands readme](https://github.com/ibm-garage-cloud/cloud-shell-commands/blob/master/README.md).\n\n</AccordionItem>\n\n<AccordionItem title=\"Install the CLI\" >\n\n- Install the CLI:\n    ```bash\n    npm i -g @ibmgaragecloud/cloud-native-toolkit-cli\n    ````\n\n- Verify the version:\n    ```bash\n    igc --version\n    ```\n\n</AccordionItem>\n\n</Accordion>\n\n## Invoking the CLI\n\n- Once the CLI is installed, the `igc` executable will be available in your system. Running `igc --help` will list the available commands.\n- The output text will be similar to the following:\n\n    ```\n    $ igc --help\n    IBM Garage Cloud-Native Toolkit CLI (https://cloudnativetoolkit.dev)\n\n    Usage: igc <command> [args]\n\n    Commands:\n      igc create-webhook      Create a git webhook for a given Jenkins pipeline\n      igc credentials         Lists the urls and credentials for the tools deployed\n                              to the cluster\n      igc dashboard           Open the Developer Dashboard in the default browser\n      igc enable              Enable the current repository with pipeline logic\n      igc endpoints           List the current ingress hosts for deployed apps in a\n                              namespace      [aliases: ingress, endpoint, ingresses]\n      igc generate-token      Generate a Jenkins api token\n      igc git-secret [name]   Create a kubernetes secret that contains the url,\n                              username, and personal access token for a git repo\n      igc jenkins-auth        Generate a Jenkins api token and register it as\n                              kubernetes secret\n      igc sync [namespace]    Create a namespace (if it does not exist) and prepare\n                              it with the necessary configuration\n                                                       [aliases: project, namespace]\n      igc pipeline            Register a pipeline for the current code repository\n      igc tool-config [name]  Create the config map and secret for a tool configured\n                              in the environment\n      igc vlan                Print out the vlan values\n      igc yq <command>        lightweight yaml command-line processor that addresses\n                              deficiencies with the existing `yq` command\n\n    Options:\n      --version  Show version number                                       [boolean]\n      --help     Show help                                                 [boolean]\n    ```\n\n- The <Globals name=\"igccli\" /> will now install the commands as plugins to the `kubectl` and `oc` CLIs.\n- For example, all of the following commands are equivalent:\n\n    ```\n    igc pipeline\n    kubectl pipeline\n    oc pipeline\n    ```\n\n### Prerequisite tools\n\n<InlineNotification>\n\nSome of the commands provided by the <Globals name=\"igccli\" /> orchestrate interactions between other CLIs. To get\nstarted please install the [prerequisite tools](/getting-started/devenvsetup), in particular:\n- <Globals name=\"kube\" /> CLI.\n- <Globals name=\"ocp\" /> CLI.\n- <Globals name=\"ic\" /> CLI--used to interact with IBM Cloud virtual LANs.\n\n</InlineNotification>\n\n### Log into your cluster\n\nMost of the commands provided by the <Globals name=\"igccli\" /> interact with a cluster, so you need to log in to be able to run these.\n\n<Accordion>\n\n<AccordionItem title=\"OpenShift\" open=\"true\">\n\n```bash\noc login --server=<url> --token=<apikey>\n```\n</AccordionItem>\n\n<AccordionItem title=\"Kubernetes\">\n\n```bash\nibmcloud ks cluster config --cluster <CLUSTER>\n```\n\n</AccordionItem>\n\n</Accordion>\n\n### Log in to your IBM Cloud account\n\n- Log in to your <Globals name=\"ic\" /> account with the correct region and resource group:\n\n    ```bash\n    ibmcloud login -a cloud.ibm.com -r <region> -g <resource group>\n    ```\n\n## Available commands\n\n### `dashboard`\n\nOpens the Developer Dashboard in the default browser. If the default browser has not been configured, then it prints the dashboard URL.\n\nThe dashboard displays the <Globals name=\"shortName\" /> tools configured within the cluster along with links to activation content and Starter Kits to initiate a project quickly.\n\nThis command requires to be logged into the cluster so the context is established.\n\n**Command flags**\n- `-n`: the namespace where the dashboard has been deployed; the default is `tools`.\n\n**Usage**\n\n<Tabs>\n<Tab label=\"CLI\">\n\nThe command syntax is:\n\n```bash\nigc dashboard\n```\n</Tab>\n<Tab label=\"OpenShift\">\n\nThe following commands does the same function on OpenShift:\n\n```bash\nHOST=$(oc get routes/dashboard -n tools -o jsonpath='{.spec.host}')\nopen \"https://$HOST\"\n```\n</Tab>\n<Tab label=\"Kubernetes\">\n\nThe following commands does the same function on Kubernetes:\n\n```bash\nHOST=$(kubectl get ingress/developer-dashboard -n tools -o jsonpath='{.spec.rules[0].host}')\nopen \"https://$HOST\"\n```\n\n</Tab>\n</Tabs>\n\n**Related commands**\n\n- [`credentials`](#credentials): shows the same credentials information that can be seen in the dashboard.\n- [`tool-config`](#tool-config): allows adding configuration for additional tools to the cluster, making them available to the dashboard and the `credentials` command.\n\n### `credentials`\n\nLists the endpoints, user names, and passwords for the tools configured in the environment. This is the easiest way to get the login credentials for each of the installed tools. Ideally, all of the tools will be accessible via SSO, at which point this command will be obsolete.\n\nThis command works by reading the information available in the cluster. For each tool installed by the toolkit, a config map and a secret are created to store its URL and credentials. This information is used in several ways within the environment:\n\n- Provide configuration information to the pipelines.\n- Populate the tiles on the Developer Dashboard.\n- Populate the results of the `credentials` command.\n\nThis command requires that the login context for the cluster has already been established.\n\n**Command flags**\n- `-n`: the namespace where the tools have been deployed. The default value is `tools`.\n\n**Usage**\n\n<Tabs>\n<Tab label=\"CLI\">\n\nThe command is used in the following way:\n\n```bash\nigc credentials\n```\n\nIt will output the credentials in JSON format:\n\n```bash\nCredentials:  {\n  argocd: {\n    user: 'admin',\n    password: '12345678',\n    url: 'https://argocd-tools.mycluster.us-east.containers.appdomain.cloud'\n  },\n  . . .\n  dashboard: {\n    url: 'https://dashboard-tools.mycluster.us-east.containers.appdomain.cloud'\n  },\n  . . .\n}\n```\n\n</Tab>\n<Tab label=\"OpenShift or Kubernetes\">\n\nThe following commands does the same function (note the dependency on `jq`):\n\n```bash\n# config maps\nkubectl get configmap -n tools -l grouping=garage-cloud-native-toolkit -o json | \\\n  jq '[.items[] | select(.metadata.name != \"ibmcloud-config\").data]'\n\n# secrets\nkubectl get secret -n tools -l grouping=garage-cloud-native-toolkit -o json | \\\n  jq '[.items[] | select(.metadata.name != \"ibmcloud-apikey\").data | with_entries(.value |= @base64d)]'\n```\n</Tab>\n</Tabs>\n\n### `endpoints`\n\nLists the ingress and/or route URLs for the applications in a given namespace. If a namespace is not provided as an argument, it will try to get it from the current context. The results are shown in an interactive menu. If one of the endpoints is selected, it will display the URL and launch it in the default browser. Selecting `Exit` will print the full list of endpoints and exit.\n\nThis command requires that the login context for the cluster has already been established.\n\n**Command flags**\n- `-n`: the namespace from which the endpoints will be retrieved. The value will be read from the current context if not provided.\n\n**Usage**\n\n<Tabs>\n<Tab label=\"CLI\">\n\nThe command is used in the following way:\n\n```bash\nigc endpoints\n```\n\n</Tab>\n<Tab label=\"OpenShift\">\n\nThe following commands list the route and ingress endpoints:\n\n```bash\n# routes\nkubectl get route -n tools\n\n# ingress\nkubectl get ingress -n tools\n```\n</Tab>\n<Tab label=\"Kubernetes\">\n\nThe following commands list the ingress endpoints:\n\n```bash\nkubectl get ingress -n tools\n```\n</Tab>\n</Tabs>\n\n### `sync`\n\nCreates a Kubernetes namespace or OpenShift project (if it doesn't already exist) and sets it up so that the namespace\ncan be used as a target for application deployments and/or host the <Globals name=\"env\" />.\n\nThe command performs two major functions, 1) set up a service account in the namespace with the pull secret(s) for the IBM Container Registry and 2) synchronize the `ConfigMaps` and `Secrets` from a template namespace to create a \"development\" namespace.\n\nOnce the command has run successfully, it will set the provided namespace in the current context (e.g. equivalent to `oc project X`).\n\nThe pull secret(s) are required for pods to pull images stored in the IBM Container Registry. When a cluster is created in IBM Cloud, a pull secret is provided in the `default` namespace.\n\nFor a pod in another namespace to use the pull secret, it must first be copied into that namespace. After that, the pod either\nneeds to reference the pull secret directly, or the service account used by the resource needs to have a reference to\nthe secret. The CLI copies the pull secret over and adds it to the service account so the pod can take either approach.\n\nThe other function this command performs is to copy relevant `ConfigMaps` and `Secrets` needed for development into the namespace. Managing resources across namespaces (particularly `ConfigMaps` and `Secrets`) is a\ncommon challenge in Kubernetes environments. We have provided the command at this time to simplify the steps required\nto get everything ready. Ultimately, this problem seems like an ideal one for a command to solve and when another one is\navailable (either from the Toolkit or elsewhere) this one will be retired or transitioned.\n\nThere are two different types of namespaces that the command will set up:\n\n- \"release\" namespace where applications can be deployed (e.g. test, staging).\n\n-OR-\n\n- \"development\" namespace where DevOps pipelines can be run and where application components can be deployed\n(e.g. dev).\n\nBoth \"release\" and \"development\" namespaces will have the pull secret(s) created. However, only the \"development\"\none will also have the `ConfigMaps` and `Secrets` copied over.\n\n**Command flags**\n- `-t`: the template namespace that will be the source of the `config maps` and `secrets`. The default is `tools`.\n- `-z`: the name of the service account. The default is `default`.\n- `--dev`: flag indicating the namespace should be set for development.\n- `--verbose`: flag indicating that the console output should persist on the screen.\n\n**Usage**\n\n<Tabs>\n<Tab label=\"CLI\">\n\nCreate a `test` namespace:\n\n```bash\nigc sync test\n```\n\nCreate a `dev` namespace for development:\n\n```bash\nigc sync dev --dev\n```\n</Tab>\n<Tab label=\"Manual pull secret setup\">\n\nThe following commands will copy the pull secret(s) from the `default` namespace and add them to the service account:\n\n```bash\nexport NAMESPACE=\"NAMESPACE\"\nexport SERVICE_ACCOUNT=\"default\"\n\nif [[ $(kubectl get secrets -n \"${NAMESPACE}\" -o jsonpath='{ range .items[*] }{ .metadata.name }{ \"\\n\" }{ end }' | grep icr | wc -l | xargs) -eq 0 ]]; then\n    echo \"*** Copying pull secrets from default namespace to the ${NAMESPACE} namespace\"\n\n    kubectl get secrets -n default | grep icr | sed \"s/\\([A-Za-z-]*\\) *.*/\\1/g\" | while read default_secret; do\n        kubectl get secret ${default_secret} -n default -o yaml --export | sed \"s/name: default-/name: /g\" | kubectl -n ${NAMESPACE} create -f -\n    done\nelse\n    echo \"*** Pull secrets already exist in the ${NAMESPACE} namespace\"\nfi\n\n\nEXISTING_SECRETS=$(kubectl get serviceaccount/${SERVICE_ACCOUNT} -n \"${NAMESPACE}\" -o json  | tr '\\n' ' ' | sed -E \"s/.*imagePullSecrets.: \\[([^]]*)\\].*/\\1/g\" | grep icr | wc -l | xargs)\nif [[ ${EXISTING_SECRETS} -eq 0 ]]; then\n    echo \"*** Adding secrets to serviceaccount/${SERVICE_ACCOUNT} in the ${NAMESPACE} namespace\"\n\n    PULL_SECRETS=$(kubectl get secrets -n \"${NAMESPACE}\" -o jsonpath='{ range .items[*] }{ \"{\\\"name\\\": \\\"\"}{ .metadata.name }{ \"\\\"}\\n\" }{ end }' | grep icr | grep -v \"${NAMESPACE}\" | paste -sd \",\" -)\n    kubectl patch -n \"${NAMESPACE}\" serviceaccount/${SERVICE_ACCOUNT} -p \"{\\\"imagePullSecrets\\\": [${PULL_SECRETS}]}\"\nelse\n  export TEMPLATE_NAMESPACE=\"tools\"\n  export NAMESPACE=\"NAMESPACE\"\n\n  kubectl get configmap -l grouping=garage-cloud-native-toolkit -n ${TEMPLATE_NAMESPACE} -o jsonpath='{ range .items[*] }{ .metadata.name }{ \"\\n\" }{ end }' | \\\n    while read cm; do\n      kubectl get configmap ${cm} --namespace ${TEMPLATE_NAMESPACE} --export -o yaml | \\\n        kubectl apply --namespace $NAMESPACE -f -\n    done\n\n  kubectl get secret -l grouping=garage-cloud-native-toolkit -n ${TEMPLATE_NAMESPACE} -o jsonpath='{ range .items[*] }{ .metadata.name }{ \"\\n\" }{ end }' | \\\n    while read cm; do\n      kubectl get secret ${cm} --namespace ${TEMPLATE_NAMESPACE} --export -o yaml | \\\n        kubectl apply --namespace $NAMESPACE -f -\n    done\n\n```\n</Tab>\n</Tabs>\n\n### `pipeline`\n\nConnects a Git repository branch to either a Jenkins or Tekton CI pipeline in the <Globals name=\"env\" /> and triggers\nan initial build. A webhook is created so that when a new commit is added to the branch, the pipeline is triggered\nto rebuild and redeploy the app with the updated code. The Git repository needs to be hosted in a service that supports triggers such as GitHub or GitLab.\n\nThis command requires the user to be logged into the cluster through a terminal, and that the terminal's current directory be your local copy of the Git repository as it uses its configuration to find the server copy.\n\nIf Jenkins or Tekton are not specified when the command is invoked you will be prompted for which CI tool to use.\nThe command will also prompt for the username and personal access token to access the Git repository unless those are\nprovided as command-line parameters. It will also prompt you for the branch to use to trigger builds. The default is the current branch.\n\n**Command flags**\n- `-n`: the deployment namespace. If not provided, the namespace from the current context will be used.\n- `-u`: the username for accessing the Git repository.\n- `-p`: the personal access token for accessing the Git repository.\n- `--jenkins`: deploy using a Jenkins pipeline.\n- `--tekton`: deploy using a Tekton pipeline.\n\n**Usage**\n\n<Tabs>\n<Tab label=\"CLI\">\nCreate a Jenkins pipeline in the `dev` namespace and prompt for the Git credentials:\n\n```bash\nigc pipeline --jenkins\n```\n\nCreate a Tekton pipeline in the `my-dev` namespace, using the Git credentials `gituser` and `gitpat`:\n\n```bash\nigc pipeline -n my-dev -u gituser -p gitpat --tekton\n```\n</Tab>\n<Tab label=\"Manual Steps for Tekton\">\n\nThe following steps are required to manually configure a **Tekton**\npipeline in your development cluster:\n<br></br>\n\n\n- Configure the service account `pipeline` if it doesn't exist. In OpenShift 4 the operator takes care of it, so you can skip this step.\n  ```bash\n  oc create serviceaccount pipeline\n  oc adm policy add-scc-to-user privileged -z pipeline\n  oc adm policy add-role-to-user edit -z pipeline\n  ```\n- Clone the tasks from the `tools` namespace into the `new-namespace` one:\n  ```\n  kubectl get tasks --export -o yaml -n tools  | sed s/\"namespace: tools/namespace: $(oc project -q)\"/ | kubectl apply -f -\n  ```\n- Clone the pipelines from the `tools` namespace into the `new-namespace` one:\n  ```\n  kubectl get pipelines --export -o yaml -n tools  | sed s/\"namespace: tools/namespace: $(oc project -q)\"/ | kubectl apply -f -\n  ```\n\n### Pipeline Resource\n\n- The `tkn` CLI creates a pipeline resource for a Git repository. Use `git` as resource type, replace the URL with the correct GitHub one for your repository, and set the desired branch for `revision`:\n  ```\n  tkn resource create\n  ? Enter a name for a pipeline resource : nodejs-typescript-git\n  ? Select a resource type to create : git\n  ? Enter a value for url :  https://github.com/{user or org}/{app}\n  ? Enter a value for revision :  master\n  New git resource \"nodejs-typescript-git\" has been created\n  ```\n- To create a Pipeline resource for the docker image registry, you can use the internal registry in OpenShift or use an external registry like IBM Container Registry (credentials need setup).\n  - With the `tkn` CLI, create an `image` resource:\n    ```\n    tkn resource create\n    ```\n  - Select `image` for type.\n\n    - Enter the corresponding `url` for the container registry, and replace `{new-namespace}` with your namespace.\n\n    - For OCP 3 internal registry use `docker-registry.default.svc:5000/{new-namespace}/node-typescript:latest`.\n\n    - For OCP 4 or CRC internal registry use `image-registry.openshift-image-registry.svc:5000/{new-namespace}/node-typescript:latest`.\n\n    - For an external registry like IBM Container Registry based on region use `us.icr.io/{namespace}/node-typescript:latest`, replacing `{namespace}` with an existing namespace in your IBM Cloud.\n    ```\n    tkn resource create\n    ? Enter a name for a pipeline resource : nodejs-typescript-image\n    ? Select a resource type to create : image\n    ? Enter a value for url :  docker-registry.default.svc:5000/dev/node-typescript:latest\n    ? Enter a value for digest :\n    New image resource \"nodejs-typescript-image\" has been created\n    ```\n\n- List the available pipelines:\n  ```\n  tkn pipeline ls\n  NAME              AGE              LAST RUN   STARTED   DURATION   STATUS\n  igc-java-gradle   33 minutes ago   ---        ---       ---        ---\n  igc-nodejs        33 minutes ago   ---        ---       ---        ---\n  ```\n  In this case we can use `igc-java-gradle` for java or `igc-nodejs` for nodejs.\n\n- Start the pipeline using the `git` and `image` pipeline resources.\n  Set the following environment variables for convienience:\n  ```\n  export PIPELINE=igc-nodejs\n  export GIT=nodejs-typescript-git\n  export IMAGE=nodejs-typescript-image\n  ```\n  Then run `tkn pipeline start` with the input arguments using the service account `pipeline`:\n  ```\n  tkn pipeline start \\\n  ${PIPELINE} \\\n  -r git-source=${GIT} \\\n  -r docker-image=${IMAGE} \\\n  -s pipeline\n  ```\n\n### Create a Git Webhook\n\n- Open the Tekton Dashboard from the main Tools Dashboard or the ICPA landing page.\n\n- Create a Webhook in the Tekton Dashboard\n\n  - Click **Webhook** on the menu.\n  - Click **Add Webhook** and enter the information for the webhook.\n    - Name: **insert name**.\n    - Repository URL: **template git repo URL**.\n    - Access Token: Create GitHub access token with permission minimum write:repo_hook.\n    - Namespace: **insert namespace**.\n    - Pipeline: select **igc-java-gradle** or **igc-nodejs**.\n    - Service Account: **pipeline**.\n    - Docker Registry:\n      - For OCP 3 internal registry use `docker-registry.default.svc:5000/{new-namespace}`.\n      - For OCP 4 or CRC internal registry use `image-registry.openshift-image-registry.svc:5000/{new-namespace}`.\n      - For an external registry like IBM Container Registry based on region use `us.icr.io/{namespace}` replacing `{namespace}` with an existing namespace from your IBM Cloud. Make sure to configure docker credentials in the Tekton Dashboard using your IAM API Key and `iamapikey` for the your namespace username.\n\n- Check that the webhook is created in the GitHub repository (Settings - Webhooks).\n\n- Make a commit to the git repo and push it to the remote git repository, or click on **Pipelines**\nand manually trigger a pipeline build.\n\n</Tab>\n<Tab label=\"Manual steps for Jenkins on OpenShift\">\n\n### 1. Provision Jenkins Ephemeral\n\nJenkins Ephemeral provides a Kubernetes native version of Jenkins that dynamically provisions build agents on-demand.\nIt's _ephemeral_ in the sense that it doesn't allocate any persistent storage in the cluster.\n\n1. Set the project/namespace:\n\n```bash\noc project {NAMESPACE}\n```\n\nwhere:\n- `{NAMESPACE}` is the development namespace where the pipelines will run.\n\n2. Run the following command to provision the Jenkins instance in your namespace:\n\n```bash\noc new-app jenkins-ephemeral\n```\n\n3. Open the OpenShift console as described in the login steps above.\n\n4. Select `Workloads -> Pods` from the left-hand menu.\n\n5. At the top of the page select your project/namespace from the drop-down list to see the Jenkins instance running.\n\n### 2. Give the `jenkins` service account `privileged` access\n\nAll of the <Globals name=\"shortName\"/> pipelines use `buildah` to build and push the container image to the registry.\nUnfortunately, the `buildah` container must run as root. By default, OpenShift does not allow containers to run as the\nroot user and special permissions are required for the pipeline to run.\n\nWith the Jenkins build engine, all the build processes run as the `jenkins` service account. For the pipeline\ncontainer to run as root on OpenShift we need to assign the `privileged` security context constraint (scc) to\nthe `jenkins` service account with the following command:\n\n```bash\noc project {NAMESPACE}\noc adm policy add-scc-to-user privileged -z jenkins\n```\n\nwhere:\n - `{NAMESPACE}` should be the name you claimed in the box note prefixed to `-dev` (e.g. user01-dev).\n\n### 3. Create a secret with Git credentials\n\nFor Jenkins to have access to the Git repository, particularly if it is a private repository, a Kubernetes\nsecret containing the git credentials needs to be added.\n\n1. Create a personal access token (if you don't already have one) using the prerequisites instructions:\nhttps://cloudnativetoolkit.dev/getting-started/prereqs#configure-github-personal-access-token\n\n2. Copy the following into a file called `gitsecret.yaml` and update {Git-Username}, and {Git-PAT}:\n\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  annotations:\n    build.openshift.io/source-secret-match-uri-1: https://github.com/*\n  labels:\n    jenkins.io/credentials-type: usernamePassword\n  name: git-credentials\ntype: kubernetes.io/basic-auth\nstringData:\n  username: {Git-Username}\n  password: {Git-PAT}\n```\n\nwhere:\n - `Git-Username` is the username that has access to the git repo\n - `Git-PAT` is the personal access token of the git user\n\n2. After logging into the cluster, create the secret by running the following:\n\n```bash\noc project {NAMESPACE}\noc create -f gitsecret.yaml\n```\n\nwhere:\n - `{NAMESPACE}` is the development namespace where the pipelines will run.\n\n### 3. Create the build config\n\nOn OpenShift 4.3, Jenkins is built into the OpenShift console and the build pipelines can be managed using Kubernetes\ncustom resources. The following steps will manually create the build pipeline for the new application.\n\n1. Copy the following into a file called `buildconfig.yaml` and update {Name}, {Secret}, {Git-Repo-URL},\nand {Namespace}:\n\n```yaml\napiVersion: v1\nkind: BuildConfig\nmetadata:\n  name: {Name}\nspec:\n  triggers:\n  - type: GitHub\n    github:\n      secret: my-secret-value\n  source:\n    git:\n      uri: {Git-Repo-URL}\n      ref: master\n  strategy:\n    jenkinsPipelineStrategy:\n      jenkinsfilePath: Jenkinsfile\n      env:\n      - name: CLOUD_NAME\n        value: openshift\n      - name: NAMESPACE\n        value: {NAMESPACE}\n```\n\nwhere:\n - `Name` is the name of your pipeline.\n - `Git-Repo-URL` is the HTTPS URL to the Git repository.\n - `{NAMESPACE}` is the development namespace where the pipelines will run.\n\n2. Assuming you are still logged into the cluster, create the `buildconfig` resource:\n\n```bash\noc project {NAMESPACE}\noc create -f buildconfig.yaml\n```\n\nwhere:\n - `{NAMESPACE}` is the development namespace where the pipelines will run.\n\n### 4. View the pipeline in the OpenShift console\n\n1. Open the cluster's OpenShift console.\n2. Select Builds -> Build Config.\n3. Select your project/namespace (i.e. `{NAMESPACE}`) from the top.\n4. The build pipeline that was created in the previous step should appear.\n5. Manually trigger the pipeline by selecting `Start Build` the menu button on the right side of the row.\n\n### 5. Create the webhook\n\n1. Run the following commands to get the webhook details from the build config:\n\n```\noc project {NAMESPACE}\noc describe bc {Name}\n```\n\nwhere:\n - `{Name}` is the name used in the previous step for the build config.\n - `{NAMESPACE}` is the development namespace where the pipelines will run.\n\nThe webhook URL will have a structure similar to:\n\n`http://{openshift_api_host:port}/oapi/v1/namespaces/{namespace}/buildconfigs/{name}/webhooks/{secret}/generic`\n\nIn this case `{secret}` will be `my-secret-value`.\n\n2. Open a browser to the GitHub repository deployed in the previous step from the build configuration.\n\n3. Select `Settings`, then `Webhooks` and press `Add webhook`.\n\n4. Paste the webhook URL from the previous step into `Payload url`.\n\n5. Set the content-type to `application/json` and leave the rest of the values with the defaults.\n\n6. Press `Add webhook` to create the webhook.\n\n7. Press the button to test the webhook to ensure that everything was done properly.\n\n8. Go back to your project code and push a change to one of the files.\n\n9. Go to the Build pipeline page in the OpenShift console to check that the build was triggered.\n\n</Tab>\n<Tab label=\"Manual steps for Jenkins on Kubernetes\">\n\nTBD\n\n</Tab>\n</Tabs>\n\n### `enable`\n\nAdds DevOps artifacts to a Git repository that the <Globals name=\"env\" /> uses to deploy the app. The command displays a\nlist of available pipelines and applies the one you select to your repository. \n\nThis command DOES NOT require the user to be logged into an IBM Cloud account nor the cluster through the terminal. It DOES\nrequire that the terminal's current directory is the one for your local copy of the Git repository.\n\nThe command will add several files to the local repo which you need to commit and push them to the server repo. These include (but are not limited to):\n\n- Helm chart.\n- `Jenkinsfile`.\n\nOnce these are pushed, run `igc pipeline` to connect your repo to a pipeline in the environment.\n\n**Command flags**\n- `--repo`: the set of pipelines to choose from; the default is https://github.com/ibm-garage-cloud/garage-pipelines.\n- `-p`: the name of the pipeline to be installed. If not provided, you will be prompted for it.\n- `-b`: the branch from which the pipeline will be installed. The default is `stable`.\n- `r`: the version number of the pipeline to be installed. The default is `latest`.\n\n**Usage**\n\n<Tabs>\n<Tab label=\"CLI\">\n\n1. Before running the command, make sure you have a clean repository with no unstaged changes. Either commit any\nchanges or stash them temporarily with `git stash`. It is particularly important that any changes to the pipeline be\ndealt with.\n\n2. Apply the pipeline updates using the following CLI command:\n\n```bash\nigc enable\n```\n\n3. Review the changes using `git diff` and revert any application-specific changes that should remain (e.g.\ncustomization to the Jenkins pipeline in the `Jenkinsfile`, specific values added to `values.yaml`, customizations\nto the templates in the Helm chart).\n\n4. Commit the changes when you are happy with them.\n\n</Tab>\n<Tab label=\"Manual steps\">\n\nThe following manual steps are equivalent to the `igc enable` command:\n\n1. Before updating the pipelines, make sure you have a clean repository with no unstaged changes. Either commit any\nchanges or stash them temporarily with `git stash`. It is particularly important that any changes to the pipeline be\ndealt with.\n\n2. Download the `index.yaml` file containing the available pipeline versions:\n\n    ```bash\n    curl -O https://ibm-garage-cloud.github.io/garage-pipelines/index.yaml\n    ```\n\n3. Look through the `index.yaml` file to identify the URL for the desired pipeline branch and version.\n\n4. With the PIPELINE_URL from the previous step, run the following to download the pipeline tar-ball:\n\n    ```bash\n    curl -O ${PIPELINE_URL}\n    ```\n\n5. Extract the tar-ball into your repository directory. You will be prompted to overwrite files. Overwrite as\nappropriate:\n\n    ```bash\n    tar xzf ${PIPELINE_FILE}\n    ```\n\n6. Review the changes using `git diff` and revert any application-specific changes that should remain like\ncustomization to the Jenkins pipeline in the `Jenkinsfile`, specific values added to `values.yaml` or customizations\nto the templates in the helm chart.\n\n7. Commit changes once you are happy with them.\n\n</Tab>\n</Tabs>\n","fileAbsolutePath":"/home/runner/work/ibm-gsi-cloudnative-journey/ibm-gsi-cloudnative-journey/src/pages/getting-started/cli/index.mdx"}}}}